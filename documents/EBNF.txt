(* General defenitions *)
    digit excluding zero = r[1-9] ;
    digit = "0" | digit excluding zero ;
    natural number = digit excluding zero, { digit } ;
    int = "0" | [ "-" ], natural number ;
    letter = r[ a-ö ] ;
    ident = letter, { letter } ;


(* Defenition of Type *)
    Int32 = "i32" ;
    Boolean = "bool" ;
    Type = Int32 | Boolean ;


(* Defenition of Literal *)
    I32 = natural number ;
    F32 = natural number, ".", natural number ;
    Bool = True | False ;
    Char = Letter ;
    String = ( letter | "_" ), { letter | "_" | digit },
    Literal = I32 | F32 | Bool | Char | String;


(* Defenition of Op *)
    Add = "+" ;
    Sub = "-" ;
    Div = "/" ;
    Multi = "*" ;
    Mod = "%" ;
    And = "&&" ;
    Or = "||" ;
    Not = "!" ;
    Equal = "==" ;
    NotEq = "!=" ;
    LessThen = "<" ;
    LargThen = ">" ;
    LessEqThen = "<=" ;
    LargEqThen = ">=" ;
    Op = Add | Sub ¦ Div ¦ Multi | Mod | And | Or | Not | Equal 
        | NotEq | LessThen |  LargThen | LessEqThen | LargEqThen ;


(* Defenition of TypeDecleration *)
    Mut = "mut" ;
    Borrow = "&" ;
    DeRef = "*" ;
    TypeDecleration = [ Borrow ], [ mut ], Type ;


(* Defenition of Expresion *)
    BinOp = Expresion, op, Expresion ;
    UnOp = op, Expresion ;
    FuncCall = [ DeRef ], Ident, "(", [ Expr, { ",", Expr } ], ")" ;
    Variable = Ident ;
    Borrowed = "&", Expresion ;
    DeRefrenced = "*", Expresion ;
    Mutable = "mut", Expresion ;
    Expresion = BinOp | UnOp | FuncCall | Variable | Literal
    	| Borrowed | DeRefrenced | Mutable ; 


(* Defenition of Statement *)
    Function = "fn", Ident, "(", [ Ident, ":", TypeDecleration ], ")", "->", TypeDecleration, "{", { Statement }, "}", ";" ;
    While = "while", Expresion, "{", { Statement }, "}", ";" ;
    If = "if", Expresion, "{", { Statement }, "}", [ "else", "{", { Statement }, "}" ], ";" ;
    Let = "let", [ Mut ], Ident, ":", TypeDecleration, "=", Expresion, ";" ;
    Assignment = [ DeRef ], Ident, "=", Expresion, ";" ;
    Return = "return", Expresion, ";" ;
    FunctionCall = FuncCall,  ";" ;
    Statement = Function | While | If | Let | Assignment | Return | FunctionCall ;


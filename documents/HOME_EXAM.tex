\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{lscape}
\usepackage{graphicx}
\usepackage{stfloats}
\usepackage{float}
\usepackage{import}
\usepackage{adjustbox}
\usepackage{hyperref}
\usepackage{apacite}
\usepackage{fancyhdr}
\usepackage{amsmath}


\pagestyle{fancy}
\lhead{Niklas Lundberg}
\rhead{inaule-6@student.ltu.se}

\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\title{Home Exam D7050E}
\author{Niklas Lundberg \\ inaule-6@student.ltu.se}
\date{\today}

\begin{document}

    \maketitle
    \newpage
	
    \section{Rubigo-lang Syntax}
    \subsection{EBNF}
    	\begin{verbatim}
(* Definition of Program *)
Program = Module ;


(* Definition of Module *)
Module = { Statement } ;


(* Definition of Statement *)
    Function = "fn", Identifier, "(", [ Identifier, ":",
        Type_Declaration, { ",", Identifier, ":", 
        Type_Declaration } ], ")", "->", Type_Declaration,
        "{", { Statement }, "}" ;
    While = "while", Expression, "{", { Statement }, "}" ;
    If = "if", Expression, "{", { Statement }, "}", [ "else",
        "{", { Statement }, "}" ] ;
    Let = "let", [ Mutable ], Identifier, ":", Type_Declaration,
        "=", Expression, ";" ;
    Assignment = [ Dereference ], Identifier, "=",
        Expression, ";" ;
    Return = "return", Expression, ";" ;
    Function_Call = E_Function_Call,  ";" ;
    Statement = Function | While | If | Let | Assignment |
        Return | Function_Call ;


(* Definition of Expression (E stands for expression) *)
    E_Binary_Operation = Expression, Binary_Operator,
        Expression ;
    E_Unary_Operation = Unary_Operator, Expression ;
    E_Function_Call = Identifier, "(", [ Expression, { ",",
        Expression } ], ")" ;
    E_Variable = Identifier ;
    E_Borrowed = "&", Expression ;
    E_Dereferenced = "*", Expression ;
    E_Mutable = Mutable, Expression ;
    Expression = E_Binary_Operation | E_Unary_Operation |
        E_Function_Call | E_Variable | Literal | E_Borrowed |
        E_Dereferenced | E_Mutable ; 


(* Definition of Type_Declaration *)
    Mutable = "mut" ;
    Borrow = "&" ;
    Dereference = "*" ;
    Type_Declaration = [ Borrow ], [ Mutable ], Type ;


(* Definition of Binary_Operator *)
    Add = "+" ;
    Sub = "-" ;
    Div = "/" ;
    Multi = "*" ;
    Mod = "%" ;
    And = "&&" ;
    Or = "||" ;
    Equal = "==" ;
    Not_Equal = "!=" ;
    Less_Then = "<" ;
    Larger_Then = ">" ;
    Less_Equal_Then = "<=" ;
    Larger_Equal_Then = ">=" ;
    Binary_Operator = Add | Sub ¦ Div ¦ Multi | Mod | And |
        Or | Not | Equal | Not_Equal | Less_Then |
        Larger_Then | Less_Equal_Then | Larger_Equal_Then ;


(* Definition of Unary Operator *)
    Sub = "+" ;
    Not = "!" ;
    Unary_Operator = Sub | Not ;


(* Definition of Literal (L stands for literal) *)
    L_I32 = Integer ;
    L_F32 = Integer, ".", Natural_Number ;
    L_Bool = True | False ;
    L_Char = "'", Character, "'" ;
    L_String = """, { Character }, """ ;  
    Literal = L_I32 | L_F32 | L_Bool | L_Char | L_String;


(* Definition of Type (T stands for type) *)
    T_Int32 = "i32" ;
    T_Float32 = "f32" ;
    T_Bool = "bool" ;
    T_Char = "Char";
    T_String = "String" ;  
    Type = T_Int32 | T_Float32 | T_Boolean | T_Char |
        T_String ;


(* General definitions *)
    Digit_Excluding_zero = r[1-9] ;
    Digit = "0" | Digit_Excluding_Zero ;
    Natural_Number = Digit_Excluding_Zero, { Digit } ;
    Integer = "0" | [ "-" ], Natural_Number ;
    Letter = r[ a-ö ] ;
    Symbol = "[" | "]" | "{" | "}" | "(" | ")" | "<" | ">"
        | "'" | '"' | "=" | "|" | "." | "," | ";" | "_" | "-" ;
    Character = Letter | Symbol | " " ;
    Identifier = ( Letter | "_" ), { Letter | "_" } ;
	\end{verbatim}

    \subsection{Example Code}
    Code example of a rubigo-lang program that prints the 10 first prime numbers.
	\begin{verbatim}
fn is_prime(num: &i32) -> bool {
    if *num < 2 {
        return false;
    }
    let half: i32 = *num/2;
    let mut count: i32 = 2;

    while count <= half {
        if (*num % count) == 0 {
            return false;
        }
        count = count + 1;
    }
    return true;
}


fn print_n_prime(n: &mut i32) -> () {
    let mut count: i32 = 1;
    while *n > 0 {
        if is_prime(&count) {
            print(count);
            *n = *n - 1;
        }
        count = count + 1;
    }
}


let mut number: i32 = 10;
print_n_prime(&mut number);

	\end{verbatim}


    \subsection{Solution compared to requirements}
 	My lexer and parser is implemented using only the standard rust library and has some advance features like having location information in the error messages. It also has a very basic error recovery system which enables the parser to keep going and find more error in the code. My parser implementation also fulfills all the requirements like parenthesized sub expressions. Thus compared to the requirements my parser is a little bit more advance.


    \section{Rubigo-lang Semantics}
    \subsection{SOS}
	General Definitions:
    	\begin{align*}
		i &= \text{Integer} \\
		f &= \text{Float} \\
		n &\in \{i, f\} \\
		b &= \text{Boolean} \\
		v &\in \{n, b\} \\
		uop &= \text{Unary Operator} \\
		bop &= \text{Binary Operator} \\
		x &= \text{Variable} \\
		p &= \text{Pointer} \\
		e &= \text{Expression} \\
		stmt &= \text{Statement} \\
		\sigma &= \text{State/Memory} \\
		fc &= \text{Function Call} \\
	\end{align*}

	Program:
	\begin{align*}
		\frac{\langle stmt_1, \sigma \rangle\Downarrow \langle void, \sigma' \rangle}
		{\langle stmt_1;stmt_2;\cdots;stmt_n, \sigma \rangle\Downarrow \langle stmt_2;\cdots;stmt_n, \sigma' \rangle}
	\end{align*}

	Block:
	\begin{align*}
		\frac{\langle stmt_1, \sigma \rangle\Downarrow \langle void, \sigma' \rangle}
		{\langle stmt_1;stmt_2;\cdots;stmt_n, \sigma \rangle\Downarrow \langle stmt_2;\cdots;stmt_n, \sigma' \rangle}
	\end{align*}
	\begin{align*}
		\frac{\langle stmt_1, \sigma \rangle\Downarrow \langle v, \sigma' \rangle}
		{\langle stmt_1;stmt_2;\cdots;stmt_n, \sigma \rangle\Downarrow \langle v, \sigma' \rangle}
	\end{align*}

	Statement:
	\begin{align*}
		\frac{\langle stmt, \sigma \rangle\Downarrow \langle \textbf{void}, \sigma' \rangle}
		{\langle stmt, \sigma \rangle\Downarrow \sigma'}
	\end{align*}
	\begin{align*}
		\frac{\langle stmt, \sigma \rangle\Downarrow \langle v, \sigma' \rangle}
		{\langle stmt, \sigma \rangle\Downarrow \langle v, \sigma' \rangle}
	\end{align*}

	
	While:
	\begin{align*}
		\frac{\langle e, \sigma \rangle\Downarrow \langle \textbf{true}, \sigma' \rangle \ \
		\langle block, \sigma' \rangle\Downarrow \sigma''}
		{\langle \textbf{while } e \textbf{ do } block, \sigma \rangle\Downarrow \langle \textbf{while } e \textbf{ do } block, \sigma'' \rangle}
	\end{align*}
	\begin{align*}
		\frac{\langle e, \sigma \rangle\Downarrow \langle \textbf{false}, \sigma' \rangle}
		{\langle \textbf{while } e \textbf{ do } block, \sigma \rangle\Downarrow \sigma'}
	\end{align*}

	If:
	\begin{align*}
		\frac{\langle e, \sigma \rangle\Downarrow \langle \textbf{true}, \sigma' \rangle \ \
		\langle block_1, \sigma' \rangle\Downarrow \sigma''}
		{\langle \textbf{if } e \textbf{ then } block_1 \textbf{ else } block_2, \sigma \rangle\Downarrow \sigma''}
	\end{align*}
	\begin{align*}
		\frac{\langle e, \sigma \rangle\Downarrow \langle \textbf{false}, \sigma' \rangle \ \
		\langle block_2, \sigma' \rangle\Downarrow \sigma''}
		{\langle \textbf{if } e \textbf{ then } block_1 \textbf{ else } block_2, \sigma \rangle\Downarrow \sigma''}
	\end{align*}

	Return:
	\begin{align*}
		\frac{\langle e, \sigma \rangle\Downarrow \langle v, \sigma' \rangle}
		{\langle \textbf{return}\ e, \sigma \rangle\Downarrow \langle v, \sigma' \rangle}
	\end{align*}

	Let/Assignment:
	\begin{align*}
		\frac{\langle e, \sigma \rangle\Downarrow \langle v, \sigma' \rangle}
		{\langle x := e, \sigma \rangle\Downarrow \langle \sigma' [x := v] \rangle}
	\end{align*}
	\begin{align*}
		\frac{\langle e, \sigma \rangle\Downarrow \langle p, \sigma' \rangle}
		{\langle x := e, \sigma \rangle\Downarrow \langle \sigma' [x := p] \rangle}
	\end{align*}

	Function Call:
	\begin{align*}
		\frac{\langle fc, \sigma \rangle\Downarrow \langle \textbf{void}, \sigma' \rangle}
		{\langle fc, \sigma \rangle\Downarrow \sigma'}
	\end{align*}
	\begin{align*}
		\frac{\langle fc, \sigma \rangle\Downarrow \langle v, \sigma' \rangle}
		{\langle fc, \sigma \rangle\Downarrow \langle v, \sigma' \rangle}
	\end{align*}

	Expression:
	\begin{align*}
		\frac{\langle e, \sigma \rangle\Downarrow \langle v, \sigma' \rangle}
		{\langle e, \sigma \rangle\Downarrow \langle v, \sigma' \rangle}
	\end{align*}
	\begin{align*}
		\frac{\langle e, \sigma \rangle\Downarrow \langle p, \sigma' \rangle}
		{\langle e, \sigma \rangle\Downarrow \langle p, \sigma' \rangle}
	\end{align*}

	Binary Operations:
	\begin{align*}
		\frac{\langle e_1, \sigma \rangle\Downarrow \langle v_1, \sigma' \rangle \ \
		\langle e_2, \sigma' \rangle\Downarrow \langle v_2, \sigma'' \rangle \ \
		\langle v_1\ \textbf{bop}\ v_2, \sigma'' \rangle\Downarrow \langle v_3, \sigma'' \rangle}
		{\langle e_1\ \textbf{bop}\ e_2, \sigma \rangle\Downarrow \langle v_3, \sigma'' \rangle}
	\end{align*}
	
	Unary Operations:
	\begin{align*}
		\frac{\langle e, \sigma \rangle\Downarrow \langle v, \sigma' \rangle \ \
		\langle uop\ v, \sigma' \rangle\Downarrow \langle v', \sigma' \rangle}
		{\langle uop\ e, \sigma \rangle\Downarrow \langle v', \sigma' \rangle}
	\end{align*}

	Borrow Variable:
	\begin{align*}
		\frac{}
		{\langle \&x, \sigma \rangle\Downarrow \langle p, \sigma \rangle}
	\end{align*}

	Dereference Pointer:
	\begin{align*}
		\frac{\langle \*p, \sigma \rangle\Downarrow \langle p', \sigma \rangle}
		{\langle \*p, \sigma \rangle\Downarrow \langle p', \sigma \rangle}
	\end{align*}

	\begin{align*}
		\frac{\langle \*p, \sigma \rangle\Downarrow \langle v, \sigma \rangle}
		{\langle \*p, \sigma \rangle\Downarrow \langle v, \sigma \rangle}
	\end{align*}	

	Variable:
	\begin{align*}
		\frac{}
		{\langle x, \sigma \rangle\Downarrow \langle v, \sigma \rangle}
	\end{align*}

	Value:
	\begin{align*}
		\frac{}
		{\langle v, \sigma \rangle\Downarrow \langle v, \sigma \rangle}
	\end{align*}

    \subsection{Example explanation}
    	TODO
    
    \subsection{Solution compared to requirements}
 	TODO





    \section{Rubigo-lang Type Checker}	
    	\subsection{Type Checking Rules}
	General Definitions:
    	\begin{align*}
		i &= \text{32 bit Integer Type} \\
		f &= \text{32 bit Float Type} \\
		n &\in \{i, f\} \\
		b &= \text{Boolean Type} \\
		uop &= \text{Unary Operator} \\
		bop &= \text{Binary Operator} \\
		x &= \text{Variable} \\
		e &= \text{Expression} \\
		\sigma &= \text{State/Memory} \\
	\end{align*}

	While:
	\begin{align*}
		\frac{\langle e, \sigma \rangle\Downarrow \langle b, \sigma' \rangle}
		{\langle \textbf{while } e \textbf{ do } block, \sigma \rangle}
	\end{align*}

	If:
	\begin{align*}
		\frac{\langle e, \sigma \rangle\Downarrow \langle b, \sigma' \rangle}
		{\langle \textbf{if } e \textbf{ then } block_1 \textbf{ else } block_2, \sigma \rangle}
	\end{align*}

	Let/Assignment:
	\begin{align*}
		\frac{
			\langle x, \sigma \rangle\Downarrow \langle n, \sigma \rangle \ \ 
			\langle e, \sigma \rangle\Downarrow \langle n, \sigma' \rangle
		}
		{\langle x := e, \sigma \rangle\Downarrow \langle \sigma' [x := n] \rangle}
	\end{align*}

	\begin{align*}
		\frac{
			\langle x, \sigma \rangle\Downarrow \langle b, \sigma \rangle \ \ 
			\langle e, \sigma \rangle\Downarrow \langle b, \sigma' \rangle
		}
		{\langle x := e, \sigma \rangle\Downarrow \langle \sigma' [x := b] \rangle}
	\end{align*}


	Arithmetic Binary Operation:
	\begin{align*}
		\frac{
		\langle e_1, \sigma \rangle\Downarrow \langle n, \sigma' \rangle \ \ 
		\langle e_2, \sigma' \rangle\Downarrow \langle n, \sigma'' \rangle \ \ 
		\frac{
			\langle bop, \sigma \rangle\Downarrow \langle op \in \{+. -, *, /, \%\} , \sigma \rangle
		}{
			\langle n\ op\ n, \sigma'' \rangle\Downarrow \langle n, \sigma''' \rangle \ \ 
		}}
		{\langle e_1\ bop\ e_2, \sigma \rangle\Downarrow \langle n, \sigma''' \rangle}
	\end{align*}


	Boolean Binary Operation:
	\begin{align*}
		\frac{
		\langle e_1, \sigma \rangle\Downarrow \langle b, \sigma' \rangle \ \ 
		\langle e_2, \sigma' \rangle\Downarrow \langle b, \sigma'' \rangle \ \ 
		\frac{
			\langle bop, \sigma \rangle\Downarrow \langle op \in \{\&\&, ||\} , \sigma \rangle
		}{
			\langle b\ op\ b, \sigma'' \rangle\Downarrow \langle b, \sigma'' \rangle \ \ 
		}}
		{\langle e_1\ bop\ e_2, \sigma \rangle\Downarrow \langle b, \sigma'' \rangle}
	\end{align*}


	Comparison Binary Operation:
	\begin{align*}
		\frac{
		\langle e_1, \sigma \rangle\Downarrow \langle n, \sigma' \rangle \ \ 
		\langle e_2, \sigma' \rangle\Downarrow \langle n, \sigma'' \rangle \ \
		\frac{
			\langle bop, \sigma \rangle\Downarrow \langle op \in \{==, !=, <=, >=, <, >\} , \sigma \rangle
		}{
			\langle n\ bop\ n, \sigma'' \rangle\Downarrow \langle b, \sigma'' \rangle
		}}
		{\langle e_1\ bop\ e_2, \sigma \rangle\Downarrow \langle b, \sigma'' \rangle}
	\end{align*}
	
	\begin{align*}
		\frac{
		\langle e_1, \sigma \rangle\Downarrow \langle b, \sigma' \rangle \ \ 
		\langle e_2, \sigma' \rangle\Downarrow \langle b, \sigma'' \rangle \ \
		\frac{
			\langle bop, \sigma \rangle\Downarrow \langle op \in \{==, !=\} , \sigma \rangle
		}{
			\langle b\ bop\ b, \sigma'' \rangle\Downarrow \langle b, \sigma'' \rangle
		}}
		{\langle e_1\ bop\ e_2, \sigma \rangle\Downarrow \langle b, \sigma'' \rangle}
	\end{align*}


	Arithmetic Unary Operation:
	\begin{align*}
		\frac{
		\langle e, \sigma \rangle\Downarrow \langle n, \sigma' \rangle \ \ 
		\frac{
			\langle uop, \sigma \rangle\Downarrow \langle -, \sigma \rangle
		}{
			\langle uop\ n, \sigma' \rangle\Downarrow \langle n, \sigma' \rangle
		}}
		{\langle uop\ e, \sigma \rangle\Downarrow \langle n, \sigma' \rangle}
	\end{align*}


	Boolean Unary Operation:
	\begin{align*}
		\frac{
		\langle e, \sigma \rangle\Downarrow \langle b, \sigma' \rangle \ \ 
		\frac{
			\langle uop, \sigma \rangle\Downarrow \langle !, \sigma \rangle
		}{
			\langle uop\ b, \sigma' \rangle\Downarrow \langle b, \sigma' \rangle
		}}
		{\langle uop\ e, \sigma \rangle\Downarrow \langle b, \sigma' \rangle}
	\end{align*}

	

		


	\subsection{Example explanation}
 		TODO
    	
	\subsection{Solution compared to requirements}
 		TODO
    




    \section{Rubigo-lang Borrow Checker}	
    	\subsection{Borrow Checking Rules}
 		TODO

	\subsection{Example explanation}
 		TODO
    	
	\subsection{Solution compared to requirements}
 		TODO



    \section{Rubigo-lang LLVM backend}	
    	Currently the LLVM backend has not been implemented for Rubigo-lang.
	


    \section{Overall course goals and learning outcomes}
    	I have learnt a lot from implementing a parser and EBNF because I encountered a lot of problems when doing so. I learnt a lot about lexical analysis from those problems, like the order the tokens are parsed is very important. And a good way to order them is by longest parser first. I didn't learn as much about syntax analysis because my compiler doesn't support context free grammar.

	From implementing the type checker I feel i haven't learnt a lot, except how complicated it can be to organize the symbol table and keep track of all the identifiers. But I have definitely learnt a lot from making the borrow checker because it was very hard to implement and I have never used Rust before. So I learnt a lot about pointers and how Rust borrow rules work.

	The interpreter also made me learn a lot because of how hard it can be to keep track of all the scopes, variables and functions. It made me think of how i could improve my parser, typechecker and borrowchecker so that it could interpret more complex features like pointers.

	Overall I think I have learnt a lot about what not to do when designing a compiler and what the challenges are. But I fell that I haven't learned a lot about the theory and solutions to those hard and complex problems. I have also learnt a lot about Rust and how borrowing works.

	
\end{document}

